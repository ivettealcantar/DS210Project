use csv::Reader;
use serde::Deserialize;
use std::error::Error;
use plotters::prelude::*;
use plotters::style::TextStyle;
use ndarray::Array1;
use plotters::prelude::*;


fn calculate_average_rate(records: &[CleanRecord]) -> f32 {
    let total_rate: f32 = records.iter().map(|r| r.incarceration_rate).sum();
    total_rate / records.len() as f32
}
fn calculate_average_crime_rate(records: &[CleanRecord]) -> f32 {
    let total_crime_rate: f32 = records.iter().map(|r| r.crime_rate).sum();
    total_crime_rate / records.len() as f32
    }

fn filter_by_state<'a>(records: &'a[CleanRecord], state: &'a str) -> Vec<&'a CleanRecord> {
    records.iter().filter(|r| r.jurisdiction == state).collect()
}
fn find_max_incarceration_rate(records: &[CleanRecord]) -> Option<&CleanRecord> {
    records.iter().max_by(|a, b| a.incarceration_rate.partial_cmp(&b.incarceration_rate).unwrap())
}
fn find_min_crime_rate(records: &[CleanRecord]) -> Option<&CleanRecord> {
    records.iter().min_by(|a, b| a.crime_rate.partial_cmp(&b.crime_rate).unwrap())
}



fn plot_rates(records: &[CleanRecord]) -> Result<(), Box<dyn Error>> {
    let root: DrawingArea<BitMapBackend<'_>, plotters::coord::Shift> = BitMapBackend::new("rates.png", (800, 600)).into_drawing_area();
    root.fill(&WHITE)?;

    let avg_incarceration = calculate_average_rate(records);
    let avg_crime = calculate_average_crime_rate(records);

    let mut chart = ChartBuilder::on(&root)
        .caption("Average Rates", ("Arial", 20))
        .x_label_area_size(50)
        .y_label_area_size(40)
        .build_cartesian_2d(0..2, 0f32..avg_incarceration.max(avg_crime) * 1.2)?;

    chart.configure_mesh()
        .disable_x_mesh()
        .disable_y_mesh()
        .x_labels(2)
        .x_label_formatter(&|x| match *x {
            0 => "Incarceration".to_string(),
            1 => "Crime".to_string(),
            _ => "".to_string(),
        })
        .y_desc("Rates")
        .draw()?;

    // Draw the bars
    chart.draw_series(vec![
        Rectangle::new([(0, 0.0), (1, avg_incarceration)], BLUE.mix(0.8).filled()),
        Rectangle::new([(1, 0.0), (2, avg_crime)], BLUE.mix(0.8).filled()),
    ])?;

    // Add text labels above each bar
    let font: TextStyle = ("sans-serif", 15).into();
    root.draw(&Text::new(
        format!("{:.2}", avg_incarceration),
        (200, (avg_incarceration + 180.0) as i32), // Adjusted y-position above the bar
        font.clone(),
    ))?;

    root.draw(&Text::new(
        format!("{:.2}", avg_crime),
        (600, (avg_incarceration +180.0) as i32), // Adjusted y-position above the bar
        font.clone(),
    ))?;

    root.present()?;
    Ok(())
}

fn linear_regression(records: &[CleanRecord]) -> Result<(), Box<dyn Error>> {
    // Extract the data
    let x: Array1<f32> = Array1::from(records.iter().map(|r| r.incarceration_rate).collect::<Vec<_>>());
    let y: Array1<f32> = Array1::from(records.iter().map(|r| r.crime_rate).collect::<Vec<_>>());

    // Calculate means
    let mean_x = x.mean().unwrap();
    let mean_y = y.mean().unwrap();

    // Calculate slope (m) and intercept (b)
    let slope = x
        .iter()
        .zip(y.iter())
        .map(|(&xi, &yi)| (xi - mean_x) * (yi - mean_y))
        .sum::<f32>()
        / x.iter()
            .map(|&xi| (xi - mean_x).powi(2))
            .sum::<f32>();

    let intercept = mean_y - slope * mean_x;

    println!("Linear Regression Equation: y = {:.4}x + {:.4}", slope, intercept);

    // Plot the regression line with data points
    let root = BitMapBackend::new("linear_regression.png", (640, 480)).into_drawing_area();
    root.fill(&WHITE)?;

    let max_x = x.iter().cloned().fold(f32::MIN, f32::max);
    let max_y = y.iter().cloned().fold(f32::MIN, f32::max);

    let mut chart = ChartBuilder::on(&root)
        .caption("Incarceration Rate vs Crime Rate", ("sans-serif", 20))
        .x_label_area_size(30)
        .y_label_area_size(30)
        .build_cartesian_2d(0.0..max_x, 0.0..max_y)?;

    chart.configure_mesh().draw()?;

    // Scatter points
    chart.draw_series(x.iter().zip(y.iter()).map(|(&xi, &yi)| {
        Circle::new((xi, yi), 3, ShapeStyle::from(&BLUE).filled())
    }))?;

    // Regression line
    chart.draw_series(LineSeries::new(
        (0..100).map(|i| {
            let x_val = i as f32 * max_x / 100.0;
            let y_val = slope * x_val + intercept;
            (x_val, y_val)
        }),
        &RED,
    ))?;

    println!("Regression plot saved to 'linear_regression.png'");

    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    // Process the dataset
    let records = process_dataset("crime_and_incarceration_by_state.csv").expect("Could not find or read the CSV file. Ensure it is placed in the correct directory.");

    // Perform linear regression and plot results
    linear_regression(&records)?;

    Ok(())
}







pub fn plot_degree_centrality(degree_centrality: &[(String, usize)]) -> Result<(), Box<dyn Error>> {
    let root = BitMapBackend::new("degree_centrality.png", (1024, 768)).into_drawing_area();
    root.fill(&WHITE)?;

    let states: Vec<_> = degree_centrality.iter().map(|(s, _)| s.clone()).collect();
    let degrees: Vec<_> = degree_centrality.iter().map(|(_, d)| *d).collect();

    // Debugging: Ensure data is valid
    println!("States: {:?}", states);
    println!("Degrees: {:?}", degrees);
    println!("States length: {}, Degrees length: {}", states.len(), degrees.len());

    if states.is_empty() || degrees.is_empty() {
        eprintln!("No data to plot degree centrality.");
        return Ok(());
    }

    let max_degree = degrees.iter().copied().max().unwrap_or(0);

    let mut chart = ChartBuilder::on(&root)
        .caption("Degree Centrality", ("Arial", 40))
        .x_label_area_size(50)
        .y_label_area_size(50)
        .build_cartesian_2d(0..states.len(), 0..(max_degree + 10))?;

    chart.configure_mesh()
        .x_desc("States")
        .y_desc("Degree")
        .x_labels(states.len()) // Use states.len() for valid labels
        .x_label_formatter(&|idx| {
            if idx < &states.len() {
                states[*idx].to_string()
            } else {
                "Unknown".to_string() // Fallback to avoid out-of-bounds
            }
        })
        .draw()?;

    chart.draw_series(states.iter().enumerate().filter_map(|(idx, state)| {
        if idx < degrees.len() {
            println!("Plotting: idx = {}, state = {}, degree = {}", idx, state, degrees[idx]);
            Some(Rectangle::new([(idx, 0), (idx + 1, degrees[idx])], BLUE.filled()))
        } else {
            None
        }
    }))?;

    println!("Bar chart saved to 'degree_centrality.png'");

    Ok(())
}